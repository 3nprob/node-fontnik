// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vector_tile.proto

#ifndef PROTOBUF_vector_5ftile_2eproto__INCLUDED
#define PROTOBUF_vector_5ftile_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace llmr {
namespace vector {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_vector_5ftile_2eproto();
void protobuf_AssignDesc_vector_5ftile_2eproto();
void protobuf_ShutdownFile_vector_5ftile_2eproto();

class value;
class feature;
class glyph;
class face;
class label;
class layer;
class tile;

enum geom_type {
  Unknown = 0,
  Point = 1,
  LineString = 2,
  Polygon = 3
};
bool geom_type_IsValid(int value);
const geom_type geom_type_MIN = Unknown;
const geom_type geom_type_MAX = Polygon;
const int geom_type_ARRAYSIZE = geom_type_MAX + 1;

// ===================================================================

class value : public ::google::protobuf::MessageLite {
 public:
  value();
  virtual ~value();

  value(const value& from);

  inline value& operator=(const value& from) {
    CopyFrom(from);
    return *this;
  }

  static const value& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const value* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(value* other);

  // implements Message ----------------------------------------------

  value* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const value& from);
  void MergeFrom(const value& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string string_value = 1;
  inline bool has_string_value() const;
  inline void clear_string_value();
  static const int kStringValueFieldNumber = 1;
  inline const ::std::string& string_value() const;
  inline void set_string_value(const ::std::string& value);
  inline void set_string_value(const char* value);
  inline void set_string_value(const char* value, size_t size);
  inline ::std::string* mutable_string_value();
  inline ::std::string* release_string_value();
  inline void set_allocated_string_value(::std::string* string_value);

  // optional float float_value = 2;
  inline bool has_float_value() const;
  inline void clear_float_value();
  static const int kFloatValueFieldNumber = 2;
  inline float float_value() const;
  inline void set_float_value(float value);

  // optional double double_value = 3;
  inline bool has_double_value() const;
  inline void clear_double_value();
  static const int kDoubleValueFieldNumber = 3;
  inline double double_value() const;
  inline void set_double_value(double value);

  // optional int64 int_value = 4;
  inline bool has_int_value() const;
  inline void clear_int_value();
  static const int kIntValueFieldNumber = 4;
  inline ::google::protobuf::int64 int_value() const;
  inline void set_int_value(::google::protobuf::int64 value);

  // optional uint64 uint_value = 5;
  inline bool has_uint_value() const;
  inline void clear_uint_value();
  static const int kUintValueFieldNumber = 5;
  inline ::google::protobuf::uint64 uint_value() const;
  inline void set_uint_value(::google::protobuf::uint64 value);

  // optional sint64 sint_value = 6;
  inline bool has_sint_value() const;
  inline void clear_sint_value();
  static const int kSintValueFieldNumber = 6;
  inline ::google::protobuf::int64 sint_value() const;
  inline void set_sint_value(::google::protobuf::int64 value);

  // optional bool bool_value = 7;
  inline bool has_bool_value() const;
  inline void clear_bool_value();
  static const int kBoolValueFieldNumber = 7;
  inline bool bool_value() const;
  inline void set_bool_value(bool value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(value)
  // @@protoc_insertion_point(class_scope:llmr.vector.value)
 private:
  inline void set_has_string_value();
  inline void clear_has_string_value();
  inline void set_has_float_value();
  inline void clear_has_float_value();
  inline void set_has_double_value();
  inline void clear_has_double_value();
  inline void set_has_int_value();
  inline void clear_has_int_value();
  inline void set_has_uint_value();
  inline void clear_has_uint_value();
  inline void set_has_sint_value();
  inline void clear_has_sint_value();
  inline void set_has_bool_value();
  inline void clear_has_bool_value();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::std::string* string_value_;
  double double_value_;
  ::google::protobuf::int64 int_value_;
  float float_value_;
  bool bool_value_;
  ::google::protobuf::uint64 uint_value_;
  ::google::protobuf::int64 sint_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vector_5ftile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vector_5ftile_2eproto();
  #endif
  friend void protobuf_AssignDesc_vector_5ftile_2eproto();
  friend void protobuf_ShutdownFile_vector_5ftile_2eproto();

  void InitAsDefaultInstance();
  static value* default_instance_;
};
// -------------------------------------------------------------------

class feature : public ::google::protobuf::MessageLite {
 public:
  feature();
  virtual ~feature();

  feature(const feature& from);

  inline feature& operator=(const feature& from) {
    CopyFrom(from);
    return *this;
  }

  static const feature& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const feature* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(feature* other);

  // implements Message ----------------------------------------------

  feature* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const feature& from);
  void MergeFrom(const feature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // repeated uint32 tags = 2 [packed = true];
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 2;
  inline ::google::protobuf::uint32 tags(int index) const;
  inline void set_tags(int index, ::google::protobuf::uint32 value);
  inline void add_tags(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      tags() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_tags();

  // optional .llmr.vector.geom_type type = 3 [default = Unknown];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::llmr::vector::geom_type type() const;
  inline void set_type(::llmr::vector::geom_type value);

  // repeated uint32 geometry = 4 [packed = true];
  inline int geometry_size() const;
  inline void clear_geometry();
  static const int kGeometryFieldNumber = 4;
  inline ::google::protobuf::uint32 geometry(int index) const;
  inline void set_geometry(int index, ::google::protobuf::uint32 value);
  inline void add_geometry(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      geometry() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_geometry();

  // repeated sint32 triangulation = 5 [packed = true];
  inline int triangulation_size() const;
  inline void clear_triangulation();
  static const int kTriangulationFieldNumber = 5;
  inline ::google::protobuf::int32 triangulation(int index) const;
  inline void set_triangulation(int index, ::google::protobuf::int32 value);
  inline void add_triangulation(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      triangulation() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_triangulation();

  // optional uint32 vertex_count = 6;
  inline bool has_vertex_count() const;
  inline void clear_vertex_count();
  static const int kVertexCountFieldNumber = 6;
  inline ::google::protobuf::uint32 vertex_count() const;
  inline void set_vertex_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:llmr.vector.feature)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_vertex_count();
  inline void clear_has_vertex_count();

  ::google::protobuf::uint64 id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > tags_;
  mutable int _tags_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > geometry_;
  mutable int _geometry_cached_byte_size_;
  int type_;
  ::google::protobuf::uint32 vertex_count_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > triangulation_;
  mutable int _triangulation_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vector_5ftile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vector_5ftile_2eproto();
  #endif
  friend void protobuf_AssignDesc_vector_5ftile_2eproto();
  friend void protobuf_ShutdownFile_vector_5ftile_2eproto();

  void InitAsDefaultInstance();
  static feature* default_instance_;
};
// -------------------------------------------------------------------

class glyph : public ::google::protobuf::MessageLite {
 public:
  glyph();
  virtual ~glyph();

  glyph(const glyph& from);

  inline glyph& operator=(const glyph& from) {
    CopyFrom(from);
    return *this;
  }

  static const glyph& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const glyph* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(glyph* other);

  // implements Message ----------------------------------------------

  glyph* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const glyph& from);
  void MergeFrom(const glyph& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional bytes bitmap = 2;
  inline bool has_bitmap() const;
  inline void clear_bitmap();
  static const int kBitmapFieldNumber = 2;
  inline const ::std::string& bitmap() const;
  inline void set_bitmap(const ::std::string& value);
  inline void set_bitmap(const char* value);
  inline void set_bitmap(const void* value, size_t size);
  inline ::std::string* mutable_bitmap();
  inline ::std::string* release_bitmap();
  inline void set_allocated_bitmap(::std::string* bitmap);

  // required uint32 width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // required uint32 height = 4;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 4;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // required sint32 left = 5;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 5;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);

  // required sint32 top = 6;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 6;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);

  // required uint32 advance = 7;
  inline bool has_advance() const;
  inline void clear_advance();
  static const int kAdvanceFieldNumber = 7;
  inline ::google::protobuf::uint32 advance() const;
  inline void set_advance(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:llmr.vector.glyph)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_bitmap();
  inline void clear_has_bitmap();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_advance();
  inline void clear_has_advance();

  ::std::string* bitmap_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::uint32 advance_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vector_5ftile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vector_5ftile_2eproto();
  #endif
  friend void protobuf_AssignDesc_vector_5ftile_2eproto();
  friend void protobuf_ShutdownFile_vector_5ftile_2eproto();

  void InitAsDefaultInstance();
  static glyph* default_instance_;
};
// -------------------------------------------------------------------

class face : public ::google::protobuf::MessageLite {
 public:
  face();
  virtual ~face();

  face(const face& from);

  inline face& operator=(const face& from) {
    CopyFrom(from);
    return *this;
  }

  static const face& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const face* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(face* other);

  // implements Message ----------------------------------------------

  face* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const face& from);
  void MergeFrom(const face& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string family = 1;
  inline bool has_family() const;
  inline void clear_family();
  static const int kFamilyFieldNumber = 1;
  inline const ::std::string& family() const;
  inline void set_family(const ::std::string& value);
  inline void set_family(const char* value);
  inline void set_family(const char* value, size_t size);
  inline ::std::string* mutable_family();
  inline ::std::string* release_family();
  inline void set_allocated_family(::std::string* family);

  // required string style = 2;
  inline bool has_style() const;
  inline void clear_style();
  static const int kStyleFieldNumber = 2;
  inline const ::std::string& style() const;
  inline void set_style(const ::std::string& value);
  inline void set_style(const char* value);
  inline void set_style(const char* value, size_t size);
  inline ::std::string* mutable_style();
  inline ::std::string* release_style();
  inline void set_allocated_style(::std::string* style);

  // repeated .llmr.vector.glyph glyphs = 5;
  inline int glyphs_size() const;
  inline void clear_glyphs();
  static const int kGlyphsFieldNumber = 5;
  inline const ::llmr::vector::glyph& glyphs(int index) const;
  inline ::llmr::vector::glyph* mutable_glyphs(int index);
  inline ::llmr::vector::glyph* add_glyphs();
  inline const ::google::protobuf::RepeatedPtrField< ::llmr::vector::glyph >&
      glyphs() const;
  inline ::google::protobuf::RepeatedPtrField< ::llmr::vector::glyph >*
      mutable_glyphs();

  // @@protoc_insertion_point(class_scope:llmr.vector.face)
 private:
  inline void set_has_family();
  inline void clear_has_family();
  inline void set_has_style();
  inline void clear_has_style();

  ::std::string* family_;
  ::std::string* style_;
  ::google::protobuf::RepeatedPtrField< ::llmr::vector::glyph > glyphs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vector_5ftile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vector_5ftile_2eproto();
  #endif
  friend void protobuf_AssignDesc_vector_5ftile_2eproto();
  friend void protobuf_ShutdownFile_vector_5ftile_2eproto();

  void InitAsDefaultInstance();
  static face* default_instance_;
};
// -------------------------------------------------------------------

class label : public ::google::protobuf::MessageLite {
 public:
  label();
  virtual ~label();

  label(const label& from);

  inline label& operator=(const label& from) {
    CopyFrom(from);
    return *this;
  }

  static const label& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const label* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(label* other);

  // implements Message ----------------------------------------------

  label* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const label& from);
  void MergeFrom(const label& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline ::google::protobuf::uint32 text() const;
  inline void set_text(::google::protobuf::uint32 value);

  // required uint32 stack = 2;
  inline bool has_stack() const;
  inline void clear_stack();
  static const int kStackFieldNumber = 2;
  inline ::google::protobuf::uint32 stack() const;
  inline void set_stack(::google::protobuf::uint32 value);

  // repeated uint32 faces = 3 [packed = true];
  inline int faces_size() const;
  inline void clear_faces();
  static const int kFacesFieldNumber = 3;
  inline ::google::protobuf::uint32 faces(int index) const;
  inline void set_faces(int index, ::google::protobuf::uint32 value);
  inline void add_faces(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      faces() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_faces();

  // repeated uint32 glyphs = 4 [packed = true];
  inline int glyphs_size() const;
  inline void clear_glyphs();
  static const int kGlyphsFieldNumber = 4;
  inline ::google::protobuf::uint32 glyphs(int index) const;
  inline void set_glyphs(int index, ::google::protobuf::uint32 value);
  inline void add_glyphs(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      glyphs() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_glyphs();

  // repeated uint32 x = 5 [packed = true];
  inline int x_size() const;
  inline void clear_x();
  static const int kXFieldNumber = 5;
  inline ::google::protobuf::uint32 x(int index) const;
  inline void set_x(int index, ::google::protobuf::uint32 value);
  inline void add_x(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      x() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_x();

  // repeated uint32 y = 6 [packed = true];
  inline int y_size() const;
  inline void clear_y();
  static const int kYFieldNumber = 6;
  inline ::google::protobuf::uint32 y(int index) const;
  inline void set_y(int index, ::google::protobuf::uint32 value);
  inline void add_y(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      y() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_y();

  // @@protoc_insertion_point(class_scope:llmr.vector.label)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_stack();
  inline void clear_has_stack();

  ::google::protobuf::uint32 text_;
  ::google::protobuf::uint32 stack_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > faces_;
  mutable int _faces_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > glyphs_;
  mutable int _glyphs_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > x_;
  mutable int _x_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > y_;
  mutable int _y_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vector_5ftile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vector_5ftile_2eproto();
  #endif
  friend void protobuf_AssignDesc_vector_5ftile_2eproto();
  friend void protobuf_ShutdownFile_vector_5ftile_2eproto();

  void InitAsDefaultInstance();
  static label* default_instance_;
};
// -------------------------------------------------------------------

class layer : public ::google::protobuf::MessageLite {
 public:
  layer();
  virtual ~layer();

  layer(const layer& from);

  inline layer& operator=(const layer& from) {
    CopyFrom(from);
    return *this;
  }

  static const layer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const layer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(layer* other);

  // implements Message ----------------------------------------------

  layer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const layer& from);
  void MergeFrom(const layer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 version = 15 [default = 1];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 15;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .llmr.vector.feature features = 2;
  inline int features_size() const;
  inline void clear_features();
  static const int kFeaturesFieldNumber = 2;
  inline const ::llmr::vector::feature& features(int index) const;
  inline ::llmr::vector::feature* mutable_features(int index);
  inline ::llmr::vector::feature* add_features();
  inline const ::google::protobuf::RepeatedPtrField< ::llmr::vector::feature >&
      features() const;
  inline ::google::protobuf::RepeatedPtrField< ::llmr::vector::feature >*
      mutable_features();

  // repeated string keys = 3;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 3;
  inline const ::std::string& keys(int index) const;
  inline ::std::string* mutable_keys(int index);
  inline void set_keys(int index, const ::std::string& value);
  inline void set_keys(int index, const char* value);
  inline void set_keys(int index, const char* value, size_t size);
  inline ::std::string* add_keys();
  inline void add_keys(const ::std::string& value);
  inline void add_keys(const char* value);
  inline void add_keys(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // repeated .llmr.vector.value values = 4;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 4;
  inline const ::llmr::vector::value& values(int index) const;
  inline ::llmr::vector::value* mutable_values(int index);
  inline ::llmr::vector::value* add_values();
  inline const ::google::protobuf::RepeatedPtrField< ::llmr::vector::value >&
      values() const;
  inline ::google::protobuf::RepeatedPtrField< ::llmr::vector::value >*
      mutable_values();

  // optional uint32 extent = 5 [default = 4096];
  inline bool has_extent() const;
  inline void clear_extent();
  static const int kExtentFieldNumber = 5;
  inline ::google::protobuf::uint32 extent() const;
  inline void set_extent(::google::protobuf::uint32 value);

  // optional uint32 vertex_count = 6;
  inline bool has_vertex_count() const;
  inline void clear_vertex_count();
  static const int kVertexCountFieldNumber = 6;
  inline ::google::protobuf::uint32 vertex_count() const;
  inline void set_vertex_count(::google::protobuf::uint32 value);

  // repeated string faces = 7;
  inline int faces_size() const;
  inline void clear_faces();
  static const int kFacesFieldNumber = 7;
  inline const ::std::string& faces(int index) const;
  inline ::std::string* mutable_faces(int index);
  inline void set_faces(int index, const ::std::string& value);
  inline void set_faces(int index, const char* value);
  inline void set_faces(int index, const char* value, size_t size);
  inline ::std::string* add_faces();
  inline void add_faces(const ::std::string& value);
  inline void add_faces(const char* value);
  inline void add_faces(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& faces() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_faces();

  // repeated .llmr.vector.label labels = 8;
  inline int labels_size() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 8;
  inline const ::llmr::vector::label& labels(int index) const;
  inline ::llmr::vector::label* mutable_labels(int index);
  inline ::llmr::vector::label* add_labels();
  inline const ::google::protobuf::RepeatedPtrField< ::llmr::vector::label >&
      labels() const;
  inline ::google::protobuf::RepeatedPtrField< ::llmr::vector::label >*
      mutable_labels();

  // repeated string stacks = 9;
  inline int stacks_size() const;
  inline void clear_stacks();
  static const int kStacksFieldNumber = 9;
  inline const ::std::string& stacks(int index) const;
  inline ::std::string* mutable_stacks(int index);
  inline void set_stacks(int index, const ::std::string& value);
  inline void set_stacks(int index, const char* value);
  inline void set_stacks(int index, const char* value, size_t size);
  inline ::std::string* add_stacks();
  inline void add_stacks(const ::std::string& value);
  inline void add_stacks(const char* value);
  inline void add_stacks(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& stacks() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_stacks();

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(layer)
  // @@protoc_insertion_point(class_scope:llmr.vector.layer)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_extent();
  inline void clear_has_extent();
  inline void set_has_vertex_count();
  inline void clear_has_vertex_count();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::llmr::vector::feature > features_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 extent_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::RepeatedPtrField< ::llmr::vector::value > values_;
  ::google::protobuf::RepeatedPtrField< ::std::string> faces_;
  ::google::protobuf::RepeatedPtrField< ::llmr::vector::label > labels_;
  ::google::protobuf::RepeatedPtrField< ::std::string> stacks_;
  ::google::protobuf::uint32 vertex_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vector_5ftile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vector_5ftile_2eproto();
  #endif
  friend void protobuf_AssignDesc_vector_5ftile_2eproto();
  friend void protobuf_ShutdownFile_vector_5ftile_2eproto();

  void InitAsDefaultInstance();
  static layer* default_instance_;
};
// -------------------------------------------------------------------

class tile : public ::google::protobuf::MessageLite {
 public:
  tile();
  virtual ~tile();

  tile(const tile& from);

  inline tile& operator=(const tile& from) {
    CopyFrom(from);
    return *this;
  }

  static const tile& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const tile* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(tile* other);

  // implements Message ----------------------------------------------

  tile* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const tile& from);
  void MergeFrom(const tile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .llmr.vector.layer layers = 3;
  inline int layers_size() const;
  inline void clear_layers();
  static const int kLayersFieldNumber = 3;
  inline const ::llmr::vector::layer& layers(int index) const;
  inline ::llmr::vector::layer* mutable_layers(int index);
  inline ::llmr::vector::layer* add_layers();
  inline const ::google::protobuf::RepeatedPtrField< ::llmr::vector::layer >&
      layers() const;
  inline ::google::protobuf::RepeatedPtrField< ::llmr::vector::layer >*
      mutable_layers();

  // repeated .llmr.vector.face faces = 4;
  inline int faces_size() const;
  inline void clear_faces();
  static const int kFacesFieldNumber = 4;
  inline const ::llmr::vector::face& faces(int index) const;
  inline ::llmr::vector::face* mutable_faces(int index);
  inline ::llmr::vector::face* add_faces();
  inline const ::google::protobuf::RepeatedPtrField< ::llmr::vector::face >&
      faces() const;
  inline ::google::protobuf::RepeatedPtrField< ::llmr::vector::face >*
      mutable_faces();

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(tile)
  // @@protoc_insertion_point(class_scope:llmr.vector.tile)
 private:

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::RepeatedPtrField< ::llmr::vector::layer > layers_;
  ::google::protobuf::RepeatedPtrField< ::llmr::vector::face > faces_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vector_5ftile_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vector_5ftile_2eproto();
  #endif
  friend void protobuf_AssignDesc_vector_5ftile_2eproto();
  friend void protobuf_ShutdownFile_vector_5ftile_2eproto();

  void InitAsDefaultInstance();
  static tile* default_instance_;
};
// ===================================================================


// ===================================================================

// value

// optional string string_value = 1;
inline bool value::has_string_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void value::set_has_string_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void value::clear_has_string_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void value::clear_string_value() {
  if (string_value_ != &::google::protobuf::internal::kEmptyString) {
    string_value_->clear();
  }
  clear_has_string_value();
}
inline const ::std::string& value::string_value() const {
  return *string_value_;
}
inline void value::set_string_value(const ::std::string& value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
}
inline void value::set_string_value(const char* value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
}
inline void value::set_string_value(const char* value, size_t size) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* value::mutable_string_value() {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  return string_value_;
}
inline ::std::string* value::release_string_value() {
  clear_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = string_value_;
    string_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void value::set_allocated_string_value(::std::string* string_value) {
  if (string_value_ != &::google::protobuf::internal::kEmptyString) {
    delete string_value_;
  }
  if (string_value) {
    set_has_string_value();
    string_value_ = string_value;
  } else {
    clear_has_string_value();
    string_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float float_value = 2;
inline bool value::has_float_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void value::set_has_float_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void value::clear_has_float_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void value::clear_float_value() {
  float_value_ = 0;
  clear_has_float_value();
}
inline float value::float_value() const {
  return float_value_;
}
inline void value::set_float_value(float value) {
  set_has_float_value();
  float_value_ = value;
}

// optional double double_value = 3;
inline bool value::has_double_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void value::set_has_double_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void value::clear_has_double_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void value::clear_double_value() {
  double_value_ = 0;
  clear_has_double_value();
}
inline double value::double_value() const {
  return double_value_;
}
inline void value::set_double_value(double value) {
  set_has_double_value();
  double_value_ = value;
}

// optional int64 int_value = 4;
inline bool value::has_int_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void value::set_has_int_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void value::clear_has_int_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void value::clear_int_value() {
  int_value_ = GOOGLE_LONGLONG(0);
  clear_has_int_value();
}
inline ::google::protobuf::int64 value::int_value() const {
  return int_value_;
}
inline void value::set_int_value(::google::protobuf::int64 value) {
  set_has_int_value();
  int_value_ = value;
}

// optional uint64 uint_value = 5;
inline bool value::has_uint_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void value::set_has_uint_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void value::clear_has_uint_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void value::clear_uint_value() {
  uint_value_ = GOOGLE_ULONGLONG(0);
  clear_has_uint_value();
}
inline ::google::protobuf::uint64 value::uint_value() const {
  return uint_value_;
}
inline void value::set_uint_value(::google::protobuf::uint64 value) {
  set_has_uint_value();
  uint_value_ = value;
}

// optional sint64 sint_value = 6;
inline bool value::has_sint_value() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void value::set_has_sint_value() {
  _has_bits_[0] |= 0x00000020u;
}
inline void value::clear_has_sint_value() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void value::clear_sint_value() {
  sint_value_ = GOOGLE_LONGLONG(0);
  clear_has_sint_value();
}
inline ::google::protobuf::int64 value::sint_value() const {
  return sint_value_;
}
inline void value::set_sint_value(::google::protobuf::int64 value) {
  set_has_sint_value();
  sint_value_ = value;
}

// optional bool bool_value = 7;
inline bool value::has_bool_value() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void value::set_has_bool_value() {
  _has_bits_[0] |= 0x00000040u;
}
inline void value::clear_has_bool_value() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void value::clear_bool_value() {
  bool_value_ = false;
  clear_has_bool_value();
}
inline bool value::bool_value() const {
  return bool_value_;
}
inline void value::set_bool_value(bool value) {
  set_has_bool_value();
  bool_value_ = value;
}

// -------------------------------------------------------------------

// feature

// optional uint64 id = 1;
inline bool feature::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void feature::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void feature::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void feature::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 feature::id() const {
  return id_;
}
inline void feature::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// repeated uint32 tags = 2 [packed = true];
inline int feature::tags_size() const {
  return tags_.size();
}
inline void feature::clear_tags() {
  tags_.Clear();
}
inline ::google::protobuf::uint32 feature::tags(int index) const {
  return tags_.Get(index);
}
inline void feature::set_tags(int index, ::google::protobuf::uint32 value) {
  tags_.Set(index, value);
}
inline void feature::add_tags(::google::protobuf::uint32 value) {
  tags_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
feature::tags() const {
  return tags_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
feature::mutable_tags() {
  return &tags_;
}

// optional .llmr.vector.geom_type type = 3 [default = Unknown];
inline bool feature::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void feature::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void feature::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void feature::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::llmr::vector::geom_type feature::type() const {
  return static_cast< ::llmr::vector::geom_type >(type_);
}
inline void feature::set_type(::llmr::vector::geom_type value) {
  assert(::llmr::vector::geom_type_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated uint32 geometry = 4 [packed = true];
inline int feature::geometry_size() const {
  return geometry_.size();
}
inline void feature::clear_geometry() {
  geometry_.Clear();
}
inline ::google::protobuf::uint32 feature::geometry(int index) const {
  return geometry_.Get(index);
}
inline void feature::set_geometry(int index, ::google::protobuf::uint32 value) {
  geometry_.Set(index, value);
}
inline void feature::add_geometry(::google::protobuf::uint32 value) {
  geometry_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
feature::geometry() const {
  return geometry_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
feature::mutable_geometry() {
  return &geometry_;
}

// repeated sint32 triangulation = 5 [packed = true];
inline int feature::triangulation_size() const {
  return triangulation_.size();
}
inline void feature::clear_triangulation() {
  triangulation_.Clear();
}
inline ::google::protobuf::int32 feature::triangulation(int index) const {
  return triangulation_.Get(index);
}
inline void feature::set_triangulation(int index, ::google::protobuf::int32 value) {
  triangulation_.Set(index, value);
}
inline void feature::add_triangulation(::google::protobuf::int32 value) {
  triangulation_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
feature::triangulation() const {
  return triangulation_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
feature::mutable_triangulation() {
  return &triangulation_;
}

// optional uint32 vertex_count = 6;
inline bool feature::has_vertex_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void feature::set_has_vertex_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void feature::clear_has_vertex_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void feature::clear_vertex_count() {
  vertex_count_ = 0u;
  clear_has_vertex_count();
}
inline ::google::protobuf::uint32 feature::vertex_count() const {
  return vertex_count_;
}
inline void feature::set_vertex_count(::google::protobuf::uint32 value) {
  set_has_vertex_count();
  vertex_count_ = value;
}

// -------------------------------------------------------------------

// glyph

// required uint32 id = 1;
inline bool glyph::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void glyph::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void glyph::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void glyph::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 glyph::id() const {
  return id_;
}
inline void glyph::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional bytes bitmap = 2;
inline bool glyph::has_bitmap() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void glyph::set_has_bitmap() {
  _has_bits_[0] |= 0x00000002u;
}
inline void glyph::clear_has_bitmap() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void glyph::clear_bitmap() {
  if (bitmap_ != &::google::protobuf::internal::kEmptyString) {
    bitmap_->clear();
  }
  clear_has_bitmap();
}
inline const ::std::string& glyph::bitmap() const {
  return *bitmap_;
}
inline void glyph::set_bitmap(const ::std::string& value) {
  set_has_bitmap();
  if (bitmap_ == &::google::protobuf::internal::kEmptyString) {
    bitmap_ = new ::std::string;
  }
  bitmap_->assign(value);
}
inline void glyph::set_bitmap(const char* value) {
  set_has_bitmap();
  if (bitmap_ == &::google::protobuf::internal::kEmptyString) {
    bitmap_ = new ::std::string;
  }
  bitmap_->assign(value);
}
inline void glyph::set_bitmap(const void* value, size_t size) {
  set_has_bitmap();
  if (bitmap_ == &::google::protobuf::internal::kEmptyString) {
    bitmap_ = new ::std::string;
  }
  bitmap_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* glyph::mutable_bitmap() {
  set_has_bitmap();
  if (bitmap_ == &::google::protobuf::internal::kEmptyString) {
    bitmap_ = new ::std::string;
  }
  return bitmap_;
}
inline ::std::string* glyph::release_bitmap() {
  clear_has_bitmap();
  if (bitmap_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bitmap_;
    bitmap_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void glyph::set_allocated_bitmap(::std::string* bitmap) {
  if (bitmap_ != &::google::protobuf::internal::kEmptyString) {
    delete bitmap_;
  }
  if (bitmap) {
    set_has_bitmap();
    bitmap_ = bitmap;
  } else {
    clear_has_bitmap();
    bitmap_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 width = 3;
inline bool glyph::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void glyph::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void glyph::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void glyph::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 glyph::width() const {
  return width_;
}
inline void glyph::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
}

// required uint32 height = 4;
inline bool glyph::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void glyph::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void glyph::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void glyph::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 glyph::height() const {
  return height_;
}
inline void glyph::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
}

// required sint32 left = 5;
inline bool glyph::has_left() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void glyph::set_has_left() {
  _has_bits_[0] |= 0x00000010u;
}
inline void glyph::clear_has_left() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void glyph::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline ::google::protobuf::int32 glyph::left() const {
  return left_;
}
inline void glyph::set_left(::google::protobuf::int32 value) {
  set_has_left();
  left_ = value;
}

// required sint32 top = 6;
inline bool glyph::has_top() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void glyph::set_has_top() {
  _has_bits_[0] |= 0x00000020u;
}
inline void glyph::clear_has_top() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void glyph::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline ::google::protobuf::int32 glyph::top() const {
  return top_;
}
inline void glyph::set_top(::google::protobuf::int32 value) {
  set_has_top();
  top_ = value;
}

// required uint32 advance = 7;
inline bool glyph::has_advance() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void glyph::set_has_advance() {
  _has_bits_[0] |= 0x00000040u;
}
inline void glyph::clear_has_advance() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void glyph::clear_advance() {
  advance_ = 0u;
  clear_has_advance();
}
inline ::google::protobuf::uint32 glyph::advance() const {
  return advance_;
}
inline void glyph::set_advance(::google::protobuf::uint32 value) {
  set_has_advance();
  advance_ = value;
}

// -------------------------------------------------------------------

// face

// required string family = 1;
inline bool face::has_family() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void face::set_has_family() {
  _has_bits_[0] |= 0x00000001u;
}
inline void face::clear_has_family() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void face::clear_family() {
  if (family_ != &::google::protobuf::internal::kEmptyString) {
    family_->clear();
  }
  clear_has_family();
}
inline const ::std::string& face::family() const {
  return *family_;
}
inline void face::set_family(const ::std::string& value) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(value);
}
inline void face::set_family(const char* value) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(value);
}
inline void face::set_family(const char* value, size_t size) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* face::mutable_family() {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  return family_;
}
inline ::std::string* face::release_family() {
  clear_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_;
    family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void face::set_allocated_family(::std::string* family) {
  if (family_ != &::google::protobuf::internal::kEmptyString) {
    delete family_;
  }
  if (family) {
    set_has_family();
    family_ = family;
  } else {
    clear_has_family();
    family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string style = 2;
inline bool face::has_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void face::set_has_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void face::clear_has_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void face::clear_style() {
  if (style_ != &::google::protobuf::internal::kEmptyString) {
    style_->clear();
  }
  clear_has_style();
}
inline const ::std::string& face::style() const {
  return *style_;
}
inline void face::set_style(const ::std::string& value) {
  set_has_style();
  if (style_ == &::google::protobuf::internal::kEmptyString) {
    style_ = new ::std::string;
  }
  style_->assign(value);
}
inline void face::set_style(const char* value) {
  set_has_style();
  if (style_ == &::google::protobuf::internal::kEmptyString) {
    style_ = new ::std::string;
  }
  style_->assign(value);
}
inline void face::set_style(const char* value, size_t size) {
  set_has_style();
  if (style_ == &::google::protobuf::internal::kEmptyString) {
    style_ = new ::std::string;
  }
  style_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* face::mutable_style() {
  set_has_style();
  if (style_ == &::google::protobuf::internal::kEmptyString) {
    style_ = new ::std::string;
  }
  return style_;
}
inline ::std::string* face::release_style() {
  clear_has_style();
  if (style_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = style_;
    style_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void face::set_allocated_style(::std::string* style) {
  if (style_ != &::google::protobuf::internal::kEmptyString) {
    delete style_;
  }
  if (style) {
    set_has_style();
    style_ = style;
  } else {
    clear_has_style();
    style_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .llmr.vector.glyph glyphs = 5;
inline int face::glyphs_size() const {
  return glyphs_.size();
}
inline void face::clear_glyphs() {
  glyphs_.Clear();
}
inline const ::llmr::vector::glyph& face::glyphs(int index) const {
  return glyphs_.Get(index);
}
inline ::llmr::vector::glyph* face::mutable_glyphs(int index) {
  return glyphs_.Mutable(index);
}
inline ::llmr::vector::glyph* face::add_glyphs() {
  return glyphs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llmr::vector::glyph >&
face::glyphs() const {
  return glyphs_;
}
inline ::google::protobuf::RepeatedPtrField< ::llmr::vector::glyph >*
face::mutable_glyphs() {
  return &glyphs_;
}

// -------------------------------------------------------------------

// label

// required uint32 text = 1;
inline bool label::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void label::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void label::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void label::clear_text() {
  text_ = 0u;
  clear_has_text();
}
inline ::google::protobuf::uint32 label::text() const {
  return text_;
}
inline void label::set_text(::google::protobuf::uint32 value) {
  set_has_text();
  text_ = value;
}

// required uint32 stack = 2;
inline bool label::has_stack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void label::set_has_stack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void label::clear_has_stack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void label::clear_stack() {
  stack_ = 0u;
  clear_has_stack();
}
inline ::google::protobuf::uint32 label::stack() const {
  return stack_;
}
inline void label::set_stack(::google::protobuf::uint32 value) {
  set_has_stack();
  stack_ = value;
}

// repeated uint32 faces = 3 [packed = true];
inline int label::faces_size() const {
  return faces_.size();
}
inline void label::clear_faces() {
  faces_.Clear();
}
inline ::google::protobuf::uint32 label::faces(int index) const {
  return faces_.Get(index);
}
inline void label::set_faces(int index, ::google::protobuf::uint32 value) {
  faces_.Set(index, value);
}
inline void label::add_faces(::google::protobuf::uint32 value) {
  faces_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
label::faces() const {
  return faces_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
label::mutable_faces() {
  return &faces_;
}

// repeated uint32 glyphs = 4 [packed = true];
inline int label::glyphs_size() const {
  return glyphs_.size();
}
inline void label::clear_glyphs() {
  glyphs_.Clear();
}
inline ::google::protobuf::uint32 label::glyphs(int index) const {
  return glyphs_.Get(index);
}
inline void label::set_glyphs(int index, ::google::protobuf::uint32 value) {
  glyphs_.Set(index, value);
}
inline void label::add_glyphs(::google::protobuf::uint32 value) {
  glyphs_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
label::glyphs() const {
  return glyphs_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
label::mutable_glyphs() {
  return &glyphs_;
}

// repeated uint32 x = 5 [packed = true];
inline int label::x_size() const {
  return x_.size();
}
inline void label::clear_x() {
  x_.Clear();
}
inline ::google::protobuf::uint32 label::x(int index) const {
  return x_.Get(index);
}
inline void label::set_x(int index, ::google::protobuf::uint32 value) {
  x_.Set(index, value);
}
inline void label::add_x(::google::protobuf::uint32 value) {
  x_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
label::x() const {
  return x_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
label::mutable_x() {
  return &x_;
}

// repeated uint32 y = 6 [packed = true];
inline int label::y_size() const {
  return y_.size();
}
inline void label::clear_y() {
  y_.Clear();
}
inline ::google::protobuf::uint32 label::y(int index) const {
  return y_.Get(index);
}
inline void label::set_y(int index, ::google::protobuf::uint32 value) {
  y_.Set(index, value);
}
inline void label::add_y(::google::protobuf::uint32 value) {
  y_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
label::y() const {
  return y_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
label::mutable_y() {
  return &y_;
}

// -------------------------------------------------------------------

// layer

// required uint32 version = 15 [default = 1];
inline bool layer::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void layer::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void layer::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void layer::clear_version() {
  version_ = 1u;
  clear_has_version();
}
inline ::google::protobuf::uint32 layer::version() const {
  return version_;
}
inline void layer::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// required string name = 1;
inline bool layer::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void layer::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void layer::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void layer::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& layer::name() const {
  return *name_;
}
inline void layer::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void layer::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void layer::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* layer::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* layer::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void layer::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .llmr.vector.feature features = 2;
inline int layer::features_size() const {
  return features_.size();
}
inline void layer::clear_features() {
  features_.Clear();
}
inline const ::llmr::vector::feature& layer::features(int index) const {
  return features_.Get(index);
}
inline ::llmr::vector::feature* layer::mutable_features(int index) {
  return features_.Mutable(index);
}
inline ::llmr::vector::feature* layer::add_features() {
  return features_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llmr::vector::feature >&
layer::features() const {
  return features_;
}
inline ::google::protobuf::RepeatedPtrField< ::llmr::vector::feature >*
layer::mutable_features() {
  return &features_;
}

// repeated string keys = 3;
inline int layer::keys_size() const {
  return keys_.size();
}
inline void layer::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& layer::keys(int index) const {
  return keys_.Get(index);
}
inline ::std::string* layer::mutable_keys(int index) {
  return keys_.Mutable(index);
}
inline void layer::set_keys(int index, const ::std::string& value) {
  keys_.Mutable(index)->assign(value);
}
inline void layer::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
}
inline void layer::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* layer::add_keys() {
  return keys_.Add();
}
inline void layer::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
}
inline void layer::add_keys(const char* value) {
  keys_.Add()->assign(value);
}
inline void layer::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
layer::keys() const {
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
layer::mutable_keys() {
  return &keys_;
}

// repeated .llmr.vector.value values = 4;
inline int layer::values_size() const {
  return values_.size();
}
inline void layer::clear_values() {
  values_.Clear();
}
inline const ::llmr::vector::value& layer::values(int index) const {
  return values_.Get(index);
}
inline ::llmr::vector::value* layer::mutable_values(int index) {
  return values_.Mutable(index);
}
inline ::llmr::vector::value* layer::add_values() {
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llmr::vector::value >&
layer::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::llmr::vector::value >*
layer::mutable_values() {
  return &values_;
}

// optional uint32 extent = 5 [default = 4096];
inline bool layer::has_extent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void layer::set_has_extent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void layer::clear_has_extent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void layer::clear_extent() {
  extent_ = 4096u;
  clear_has_extent();
}
inline ::google::protobuf::uint32 layer::extent() const {
  return extent_;
}
inline void layer::set_extent(::google::protobuf::uint32 value) {
  set_has_extent();
  extent_ = value;
}

// optional uint32 vertex_count = 6;
inline bool layer::has_vertex_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void layer::set_has_vertex_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void layer::clear_has_vertex_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void layer::clear_vertex_count() {
  vertex_count_ = 0u;
  clear_has_vertex_count();
}
inline ::google::protobuf::uint32 layer::vertex_count() const {
  return vertex_count_;
}
inline void layer::set_vertex_count(::google::protobuf::uint32 value) {
  set_has_vertex_count();
  vertex_count_ = value;
}

// repeated string faces = 7;
inline int layer::faces_size() const {
  return faces_.size();
}
inline void layer::clear_faces() {
  faces_.Clear();
}
inline const ::std::string& layer::faces(int index) const {
  return faces_.Get(index);
}
inline ::std::string* layer::mutable_faces(int index) {
  return faces_.Mutable(index);
}
inline void layer::set_faces(int index, const ::std::string& value) {
  faces_.Mutable(index)->assign(value);
}
inline void layer::set_faces(int index, const char* value) {
  faces_.Mutable(index)->assign(value);
}
inline void layer::set_faces(int index, const char* value, size_t size) {
  faces_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* layer::add_faces() {
  return faces_.Add();
}
inline void layer::add_faces(const ::std::string& value) {
  faces_.Add()->assign(value);
}
inline void layer::add_faces(const char* value) {
  faces_.Add()->assign(value);
}
inline void layer::add_faces(const char* value, size_t size) {
  faces_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
layer::faces() const {
  return faces_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
layer::mutable_faces() {
  return &faces_;
}

// repeated .llmr.vector.label labels = 8;
inline int layer::labels_size() const {
  return labels_.size();
}
inline void layer::clear_labels() {
  labels_.Clear();
}
inline const ::llmr::vector::label& layer::labels(int index) const {
  return labels_.Get(index);
}
inline ::llmr::vector::label* layer::mutable_labels(int index) {
  return labels_.Mutable(index);
}
inline ::llmr::vector::label* layer::add_labels() {
  return labels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llmr::vector::label >&
layer::labels() const {
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::llmr::vector::label >*
layer::mutable_labels() {
  return &labels_;
}

// repeated string stacks = 9;
inline int layer::stacks_size() const {
  return stacks_.size();
}
inline void layer::clear_stacks() {
  stacks_.Clear();
}
inline const ::std::string& layer::stacks(int index) const {
  return stacks_.Get(index);
}
inline ::std::string* layer::mutable_stacks(int index) {
  return stacks_.Mutable(index);
}
inline void layer::set_stacks(int index, const ::std::string& value) {
  stacks_.Mutable(index)->assign(value);
}
inline void layer::set_stacks(int index, const char* value) {
  stacks_.Mutable(index)->assign(value);
}
inline void layer::set_stacks(int index, const char* value, size_t size) {
  stacks_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* layer::add_stacks() {
  return stacks_.Add();
}
inline void layer::add_stacks(const ::std::string& value) {
  stacks_.Add()->assign(value);
}
inline void layer::add_stacks(const char* value) {
  stacks_.Add()->assign(value);
}
inline void layer::add_stacks(const char* value, size_t size) {
  stacks_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
layer::stacks() const {
  return stacks_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
layer::mutable_stacks() {
  return &stacks_;
}

// -------------------------------------------------------------------

// tile

// repeated .llmr.vector.layer layers = 3;
inline int tile::layers_size() const {
  return layers_.size();
}
inline void tile::clear_layers() {
  layers_.Clear();
}
inline const ::llmr::vector::layer& tile::layers(int index) const {
  return layers_.Get(index);
}
inline ::llmr::vector::layer* tile::mutable_layers(int index) {
  return layers_.Mutable(index);
}
inline ::llmr::vector::layer* tile::add_layers() {
  return layers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llmr::vector::layer >&
tile::layers() const {
  return layers_;
}
inline ::google::protobuf::RepeatedPtrField< ::llmr::vector::layer >*
tile::mutable_layers() {
  return &layers_;
}

// repeated .llmr.vector.face faces = 4;
inline int tile::faces_size() const {
  return faces_.size();
}
inline void tile::clear_faces() {
  faces_.Clear();
}
inline const ::llmr::vector::face& tile::faces(int index) const {
  return faces_.Get(index);
}
inline ::llmr::vector::face* tile::mutable_faces(int index) {
  return faces_.Mutable(index);
}
inline ::llmr::vector::face* tile::add_faces() {
  return faces_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::llmr::vector::face >&
tile::faces() const {
  return faces_;
}
inline ::google::protobuf::RepeatedPtrField< ::llmr::vector::face >*
tile::mutable_faces() {
  return &faces_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vector
}  // namespace llmr

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_vector_5ftile_2eproto__INCLUDED
